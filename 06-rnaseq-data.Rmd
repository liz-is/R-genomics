---
layout: topic
title: Working with RNA-seq data
author: Data Carpentry contributors
minutes: 30
---

```{r echo=FALSE}
library(tidyverse)
```

> ## Learning Objectives 
* Recall principles of data tidiness
* Use dplyr and plotting with ggplot2 to explore RNA-seq data

In this lesson we're going to use a published RNA-seq dataset to show how the concepts and tools from previous lessons can be applied to genomic data. The data comes fom Jeong et al., 2017 (https://www.nature.com/articles/s41467-017-00738-7) and is a summary of RNA-seq data from the mosue retina from five different timepoints with three replicates at each timepoint. (HTSeq)[https://htseq.readthedocs.io/en/release_0.9.1/overview.html] was used to count the number of reads from each RNA-seq dataset aligning to each mouse gene. 

First let's read in the prepared data and create a data frame. 

```{r}
expression_df <- read.table("expression_data.tsv", sep = "\t", header = TRUE)
head(expression_df)
```

> ## Challenge
With a partner, discuss the data tidiness principles from yesterday and write the ones you can remember in the etherpad.

> ## Challenge
Take a look at the RNA-seq dataset. What data does each column hold? Does this data frame follow the data tidiness principles? Hint: the `summary` function might be useful here. 

This dataset follows the data tidiness principles from the data organisation lesson: each column contains a different variable and each row is a different observation. 

As well as the RNA-seq data itself (the "norm_counts" column), it also contains some extra information about the genes, such as the different gene biotypes. For this lesson, we're only interested in protein coding genes, so let's subset the data to remove other gene biotypes. First, what gene biotypes are in this dataset?

```{r}
table(expression_df$gene_biotype)
```

Most genes are protein coding but there are many other gene biotypes present.

```{r}
filtered_df <- filter(expression_df, gene_biotype == "protein_coding")
table(filtered_df$gene_biotype)
```

> ## Challenge
How many different timepoint are there in this dataset? How many different replicates are there for each timepoint?

```{r}
table(filtered_df$replicate, filtered_df$timepoint)
```

There are five different timepoint with three replicates each.


How much variability is there between replicates? Let's make some plots to see, but we'll just use a subset of the data. We can use `filter` to select a subset of the data.

```{r}
genes_sub <- counts_long$ensembl_gene_id[1:10]

counts_sub <- filter(counts_long, ensembl_gene_id %in% genes_sub)

ggplot(counts_sub, aes(x = ensembl_gene_id, y = counts, shape = replicate, colour = timepoint)) +
  geom_point() 
```

The three replicates at each timepoint look pretty close for all these genes, so let's assume that there's no systematic biases between the three replicates. There are better ways to check if there are biases or batch effects in your RNA-seq data, like performing a Principal Component Analysis, but we don't have time to cover that here.

Remember the split-apply-combine concept from the dplyr lesson? We can apply that here to get the average expression for each gene at each timepoint. Here we're splitting the data into groups based on the gene id and timepoint, then summarising each group by taking the mean of the counts and putting it in a new column. 

```{r}
counts_summary <- counts_long %>%
  group_by(ensembl_gene_id, timepoint) %>%
  summarise(mean_counts = mean(counts))

```

We can plot the results with ggplot to see what the overall gene expression pattern looks like over time. 

```{r}
ggplot(counts_summary, aes(x = timepoint, y = mean_counts)) +
  geom_boxplot() +
  scale_y_log10()
```

Notice the order of the x axis. This is sorted alphabetically, which doesn't give us the right order in time. The "timepoint" column is a factor, and the levels of the factor are by default sorted alphabetically, but we can change that by manually specifying the order we want the levels to be in. To do this, we can use the "mutate" function from dplyr.

```{r}
counts_summary <- mutate(counts_summary, timepoint = factor(timepoint, levels = c("P6", "P10", "P15", "P21", "P50")))

ggplot(counts_summary, aes(x = timepoint, y = mean_counts)) +
  geom_boxplot() +
  scale_y_log10()
```

That's better! 

Let's add some extra information to make this data more useful. For example, it's often useful to know the common names of the genes, and we might also want to know the lengths of the genes so we can calculate the expression normalised to the length of the gene.

```{r}
genes_df <- read.table("gene_data.tsv", sep = "\t", header = TRUE)

counts_summary <- left_join(counts_summary, genes_df)
```

The `genes_df` data frame also includes a column called "cluster". This contains cluster information from the paper - the authors identified seven clusters with different expression patterns over time.

```{r}
ggplot(counts_summary, aes(x = timepoint, y = mean_counts)) +
  geom_boxplot() +
  scale_y_log10() + 
  facet_wrap(~cluster)
```

## Possible exercises

* Calculate expression normalised by gene length? (using mutate)
* Calculate CPM / FPKM (would require another table with library sizes, using joins and mutate)
* Filter for only protein-coding genes (filter)
* Find top expressed genes at different timepoints / in each cluster (using filter and arrange)
* Normalise gene expression by to 0-1 for each gene in order to plot cluster expression patterns (using group_by, summarise, and mutate, and ggplot) (plotting cluster expression patterns with geom_line looks like a mess unless you do this)
* Add data on which genes are differentially expressed and do some plotting marking these genes? (joins, ggplot)

